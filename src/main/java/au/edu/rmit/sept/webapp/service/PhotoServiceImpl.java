package au.edu.rmit.sept.webapp.service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import au.edu.rmit.sept.webapp.model.Event_Photos;
import au.edu.rmit.sept.webapp.repository.PhotoRepository;

@Service
public class PhotoServiceImpl implements PhotoService {

    private final PhotoRepository photoRepository;
    
    @Value("${app.upload.dir:uploads}")
    private String uploadDir;
    
    private static final long MAX_FILE_SIZE = 25 * 1024 * 1024; // 25MB
    private static final String[] ALLOWED_EXTENSIONS = {".jpg", ".jpeg", ".png", ".gif", ".webp"};

    public PhotoServiceImpl(PhotoRepository photoRepository) {
        this.photoRepository = photoRepository;
    }

    @Override
    public Event_Photos uploadPhoto(int eventId, int organiserId, MultipartFile file) {
        if (file.isEmpty()) {
            throw new IllegalArgumentException("File cannot be empty");
        }
        
        if (!isValidImageFile(file)) {
            throw new IllegalArgumentException("Invalid image file format");
        }
        
        if (file.getSize() > MAX_FILE_SIZE) {
            throw new IllegalArgumentException("File size exceeds maximum limit of 25MB");
        }
        
        try {
            // Generate unique filename
            String originalFilename = file.getOriginalFilename();
            String extension = originalFilename != null && originalFilename.contains(".") 
                ? originalFilename.substring(originalFilename.lastIndexOf("."))
                : ".jpg";
            String fileName = UUID.randomUUID().toString() + extension;
            
            // Save file to upload directory
            String fileUrl = saveFile(file, fileName);
            
            // Create photo record
            Event_Photos photo = new Event_Photos(
                0, // ID will be generated by database
                eventId,
                organiserId,
                fileUrl,
                LocalDateTime.now()
            );
            
            return photoRepository.save(photo);
            
        } catch (Exception e) {
            throw new RuntimeException("Failed to upload photo: " + e.getMessage(), e);
        }
    }

    @Override
    public List<Event_Photos> uploadMultiplePhotos(int eventId, int organiserId, List<MultipartFile> files) {
        if (files == null || files.isEmpty()) {
            throw new IllegalArgumentException("No files provided for upload");
        }
        
        // Filter out empty files
        List<MultipartFile> validFiles = files.stream()
            .filter(file -> !file.isEmpty())
            .toList();
            
        if (validFiles.isEmpty()) {
            throw new IllegalArgumentException("All files are empty");
        }
        
        List<Event_Photos> uploadedPhotos = new ArrayList<>();
        List<String> errors = new ArrayList<>();
        
        for (MultipartFile file : validFiles) {
            try {
                Event_Photos uploadedPhoto = uploadPhoto(eventId, organiserId, file);
                uploadedPhotos.add(uploadedPhoto);
            } catch (Exception e) {
                String filename = file.getOriginalFilename() != null ? file.getOriginalFilename() : "unknown";
                errors.add("Failed to upload " + filename + ": " + e.getMessage());
            }
        }
        
        // If we have some successes but also some errors, include error info but still return successes
        if (!errors.isEmpty() && !uploadedPhotos.isEmpty()) {
            throw new RuntimeException("Some files failed to upload: " + String.join("; ", errors) + 
                                     ". Successfully uploaded " + uploadedPhotos.size() + " file(s).");
        }
        
        // If all failed, throw error with all failure reasons
        if (uploadedPhotos.isEmpty()) {
            throw new RuntimeException("All files failed to upload: " + String.join("; ", errors));
        }
        
        return uploadedPhotos;
    }

    @Override
    public List<Event_Photos> getEventPhotos(int eventId) {
        return photoRepository.findByEventId(eventId);
    }

    @Override
    public List<Event_Photos> getAllPhotos() {
        return photoRepository.findAll();
    }

    @Override
    public List<Event_Photos> getPhotosByOrganiser(int organiserId) {
        return photoRepository.findByOrganiserId(organiserId);
    }

    @Override
    public Optional<Event_Photos> getPhotoById(int photoId) {
        return photoRepository.findById(photoId);
    }

    @Override
    public void deletePhoto(int photoId) {
        Optional<Event_Photos> photo = photoRepository.findById(photoId);
        if (photo.isPresent()) {
            // Delete file from filesystem
            try {
                Path filePath = Paths.get(photo.get().url());
                Files.deleteIfExists(filePath);
            } catch (IOException e) {
                // Log error but continue with database deletion
                System.err.println("Failed to delete file: " + e.getMessage());
            }
            
            // Delete database record
            photoRepository.deleteById(photoId);
        }
    }

    @Override
    public void deleteMultiplePhotos(List<Integer> photoIds) {
        if (photoIds == null || photoIds.isEmpty()) {
            return;
        }

        // First, get all photos to delete their files from filesystem
        List<Event_Photos> photosToDelete = new ArrayList<>();
        for (Integer photoId : photoIds) {
            Optional<Event_Photos> photo = photoRepository.findById(photoId);
            if (photo.isPresent()) {
                photosToDelete.add(photo.get());
            }
        }

        // Delete files from filesystem
        for (Event_Photos photo : photosToDelete) {
            try {
                Path filePath = Paths.get(photo.url());
                Files.deleteIfExists(filePath);
            } catch (IOException e) {
                // Log error but continue with database deletion
                System.err.println("Failed to delete file: " + e.getMessage());
            }
        }

        // Delete all database records at once
        photoRepository.deleteMultipleById(photoIds);
    }

    @Override
    public boolean isValidImageFile(MultipartFile file) {
        if (file.isEmpty()) {
            return false;
        }
        
        String originalFilename = file.getOriginalFilename();
        if (originalFilename == null || originalFilename.trim().isEmpty()) {
            return false;
        }
        
        String filename = originalFilename.toLowerCase();
        
        for (String ext : ALLOWED_EXTENSIONS) {
            if (filename.endsWith(ext)) {
                return true;
            }
        }
        
        return false;
    }

    @Override
    public String saveFile(MultipartFile file, String fileName) {
        try {
            // Create upload directory if it doesn't exist
            Path uploadPath = Paths.get(uploadDir);
            if (!Files.exists(uploadPath)) {
                Files.createDirectories(uploadPath);
            }
            
            // Save file
            Path filePath = uploadPath.resolve(fileName);
            Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);
            
            // Return relative path for database storage
            return "/event_photos/" + fileName;
            
        } catch (IOException e) {
            throw new RuntimeException("Failed to save file: " + fileName, e);
        }
    }

    @Override
    public List<Event_Photos> getEventPhotoThumbnails(int eventId, int limit) {
        try {
            List<Event_Photos> allPhotos = photoRepository.findByEventId(eventId);
            
            // Return up to 'limit' number of photos for thumbnails
            // Using stream to limit the results
            return allPhotos.stream()
                    .limit(limit)
                    .toList();
        } catch (Exception e) {
            // Return empty list if there's an error
            System.err.println("Error fetching photo thumbnails for event " + eventId + ": " + e.getMessage());
            return new ArrayList<>();
        }
    }
}