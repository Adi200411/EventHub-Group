package au.edu.rmit.sept.webapp.dto;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

import au.edu.rmit.sept.webapp.model.Event;


public final class EventFormMapper {
    private EventFormMapper() {}

  
    public static Event toNewEntity(EventForm f, Long organiserId, Long clubId) {
        final LocalDate date = f.getEventDate();
        final LocalTime st   = f.getStartTime();
        final LocalTime et   = f.getEndTime();

        // Prefer explicit args; fallback to form fields; then default 0
        final Long org  = (organiserId != null) ? organiserId : f.getOrganiserId();

        final Long club = clubId != null ? clubId :  f.getClubId() ;

        // Compose full LocalDateTime for start_time (avoids "Incorrect datetime value: 'HH:mm:ss'")
        final LocalDateTime startDateTime =
                (date != null && st != null) ? date.atTime(st) : null;

        // Store finish_time as HH:mm:ss string (tolerated by TIME and DATETIME columns)
        final String finishTimeString = (et != null) ? et.withSecond(0).format(TIME_24H_SEC) : null;

        final String status = (f.getStatus() == null || f.getStatus().isBlank())
                ? "ACTIVE" : f.getStatus().trim();

        return new Event(
                0,                // event_id (generated by DB)
                org,
                club,
                f.getTitle(),
                f.getDescription(),
                f.getLocation(),
                date,
                startDateTime,
                finishTimeString,
                status,
                f.getCapacity()
        );
    }

    
    public static Event applyToEntity(EventForm f, Event existing) {
        final LocalDate date = f.getEventDate();
        final LocalTime st   = f.getStartTime();
        final LocalTime et   = f.getEndTime();

        final Long org  = (f.getOrganiserId() != null) ? f.getOrganiserId() : (existing.organiser_id() != null ? existing.organiser_id() : null);
        final Long club = (f.getClubId() != null)      ? f.getClubId()      : existing.club_id();

        final LocalDateTime startDateTime =
                (date != null && st != null) ? date.atTime(st) : null;

        // If end time provided, normalize to HH:mm:ss; else keep existing string
        final String finishTimeString = (et != null)
                ? et.withSecond(0).format(TIME_24H_SEC)
                : existing.finish_time();

        final String status = (f.getStatus() == null || f.getStatus().isBlank())
                ? existing.status() : f.getStatus().trim();

        return new Event(
                existing.event_id(),
                org,
                club,
                f.getTitle(),
                f.getDescription(),
                f.getLocation(),
                date,
                startDateTime,
                finishTimeString,
                status,
                f.getCapacity()
        );
    }

    /** Convert Event â†’ EventForm (useful for edit screens). */
    public static EventForm fromEntity(Event e) {
        EventForm f = new EventForm();

        // Optional context
        f.setOrganiserId(e.organiser_id());
        f.setClubId(e.club_id());

        f.setTitle(e.title());
        f.setDescription(e.description());
        f.setLocation(e.location());
        f.setEventDate(e.date());

        if (e.start_time() != null) {
            // f.setStartTime(e.start_time().toLocalTime());
            f.setStartTime(e.start_time().toLocalTime()); // <-- store as LocalTime for the form
        }

        if (e.finish_time() != null && !e.finish_time().isBlank()) {
            // f.setEndTime(parseTimeSafe(e.finish_time())); // accepts "HH:mm" or "HH:mm:ss"
            LocalTime ft = parseTimeSafe(e.finish_time()); // parse to LocalTime first
            f.setEndTime(ft);         // <-- store as LocalTime for the form
        }

        f.setStatus(e.status());
        f.setCapacity(e.capacity());
        return f;
    }

    
private static final DateTimeFormatter TIME_24H_UI   = DateTimeFormatter.ofPattern("HH:mm");
private static final DateTimeFormatter TIME_24H_SEC  = DateTimeFormatter.ofPattern("HH:mm:ss");
private static final DateTimeFormatter DT_SPACE_MIN  = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
private static final DateTimeFormatter DT_SPACE_SEC  = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

// --- helpers ---
private static LocalTime parseTimeSafe(String s) {
    if (s == null) return null;
    String t = s.trim();
    if (t.isEmpty()) return null;

    // 1) ISO-like datetime (contains 'T')
    try {
        if (t.contains("T")) {
            return LocalDateTime.parse(t).toLocalTime();
        }
    } catch (Exception ignored) {}

    // 2) "yyyy-MM-dd HH:mm[:ss]"
    try { return LocalDateTime.parse(t, DT_SPACE_SEC).toLocalTime(); } catch (Exception ignored) {}
    try { return LocalDateTime.parse(t, DT_SPACE_MIN).toLocalTime(); } catch (Exception ignored) {}

    // 3) plain time "HH:mm[:ss]"
    try { return LocalTime.parse(t, TIME_24H_UI); }  catch (Exception ignored) {}
    try { return LocalTime.parse(t, TIME_24H_SEC); } catch (Exception ignored) {}

    // 4) last-resort flexible parse
    try { return LocalTime.parse(t); } catch (Exception ignored) {}

    throw new IllegalArgumentException("Invalid finish time: " + s);
}

}
